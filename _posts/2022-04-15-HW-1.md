---
layout: post
title: Visualizing Climate Data with Plotly
---
In this blog post, I'll demonstrate how to create interactive visualizations using SQL and plotly.

## 1. Create a Database

First, we must construct the database and load information from csv files into sql tables that can be queried. Import the necessary packages.


```python
import numpy as np
import pandas as pd
import sqlite3
from plotly import express as px
```

There are three csv files to be added to the database: "temps_stacked.csv", "countries.csv", and "station-metadata.csv". Use the pandas `read_csv` function to read each csv file into a DataFrame, and examine each DataFrame with the `head()` function.


```python
temps = pd.read_csv("temps_stacked.csv")
temps.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ID</th>
      <th>Year</th>
      <th>Month</th>
      <th>Temp</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>1</td>
      <td>-0.89</td>
    </tr>
    <tr>
      <th>1</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>2</td>
      <td>2.36</td>
    </tr>
    <tr>
      <th>2</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>3</td>
      <td>4.72</td>
    </tr>
    <tr>
      <th>3</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>4</td>
      <td>7.73</td>
    </tr>
    <tr>
      <th>4</th>
      <td>ACW00011604</td>
      <td>1961</td>
      <td>5</td>
      <td>11.28</td>
    </tr>
  </tbody>
</table>
</div>



The csv file "temps_stacked.csv" gives average temperature readings at various stations around the world (identified by ID), with each station having readings from each month in a span of several years.


```python
countries = pd.read_csv("countries.csv")
countries.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>FIPS 10-4</th>
      <th>ISO 3166</th>
      <th>Name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>AF</td>
      <td>AF</td>
      <td>Afghanistan</td>
    </tr>
    <tr>
      <th>1</th>
      <td>AX</td>
      <td>-</td>
      <td>Akrotiri</td>
    </tr>
    <tr>
      <th>2</th>
      <td>AL</td>
      <td>AL</td>
      <td>Albania</td>
    </tr>
    <tr>
      <th>3</th>
      <td>AG</td>
      <td>DZ</td>
      <td>Algeria</td>
    </tr>
    <tr>
      <th>4</th>
      <td>AQ</td>
      <td>AS</td>
      <td>American Samoa</td>
    </tr>
  </tbody>
</table>
</div>



The csv file "countries.csv" specifies a "FIPS 10-4" and "ISO 3166" code name to each country in the world. I'll rename these columns to "FIPS_10-4" and "ISO_3166", respectively, to avoid any issues with spaces.


```python
# use df.rename to rename the columns with spaces
countries = countries.rename(columns = {"FIPS 10-4": "FIPS_10-4"})
countries = countries.rename(columns = {"ISO 3166": "ISO_3166"})
```


```python
stations = pd.read_csv("station-metadata.csv")
stations.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ID</th>
      <th>LATITUDE</th>
      <th>LONGITUDE</th>
      <th>STNELEV</th>
      <th>NAME</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>ACW00011604</td>
      <td>57.7667</td>
      <td>11.8667</td>
      <td>18.0</td>
      <td>SAVE</td>
    </tr>
    <tr>
      <th>1</th>
      <td>AE000041196</td>
      <td>25.3330</td>
      <td>55.5170</td>
      <td>34.0</td>
      <td>SHARJAH_INTER_AIRP</td>
    </tr>
    <tr>
      <th>2</th>
      <td>AEM00041184</td>
      <td>25.6170</td>
      <td>55.9330</td>
      <td>31.0</td>
      <td>RAS_AL_KHAIMAH_INTE</td>
    </tr>
    <tr>
      <th>3</th>
      <td>AEM00041194</td>
      <td>25.2550</td>
      <td>55.3640</td>
      <td>10.4</td>
      <td>DUBAI_INTL</td>
    </tr>
    <tr>
      <th>4</th>
      <td>AEM00041216</td>
      <td>24.4300</td>
      <td>54.4700</td>
      <td>3.0</td>
      <td>ABU_DHABI_BATEEN_AIR</td>
    </tr>
  </tbody>
</table>
</div>



The csv file "station-metadata.csv" gives ID, latitude, longitude, elevation, and name information for each of the unique stations in the "temps_stacked.csv" file. Each station's ID in this DataFrame matches its ID in the temps DataFrame.

Finally, we can open a connection to a database named "temps.db", and use `to_sql()` to load each DataFrame into the database. Remember to always close the connection.


```python
conn = sqlite3.connect("temps.db")

# The temps df is given the name "temperatures" in the database.
# Similarly, countries is given the name "countries" and stations "stations".
temps.to_sql("temperatures", conn, if_exists="replace", index=False)
countries.to_sql("countries", conn, if_exists="replace", index=False)
stations.to_sql("stations", conn, if_exists="replace", index=False)

conn.close()
```

## 2. Write a Query Function

Our first step is to create a function that can query the database so that we can choose the data that we need for a visualization. In this case, we want our queried database to contain information on stations in a specified country and month, ranging from a specified starting year to a specified ending year. Each entry should display the station's name, latitude, longitude, country, year, month, and temperature at that given year.


```python
def query_climate_database(country, year_begin, year_end, month):
    """
    Queries the temps.db database, displaying name, location, date, and temperature information
    of stations in a specified country, month, and year range.
    
    Parameters
    ----------
       country: string, the unabbreviated name of the specified country in the query
    year_begin: int, the starting year of the specified year range
      year_end: int, the ending year of the specified year range
         month: int, the specified month (as a number between 1 and 12) in the query
    
    Return
    ------
            df: DataFrame, the completed query as a pandas DataFrame
    """
    
    # Use the countries DataFrame to extract the FIPS 10-4 ID of the specified country.
    # countries.loc[countries["Name"] == country] returns the one entry of the countries
    # DataFrame with the Name column matching the unabbreviated country name. Indexing
    # its "FIPS_10-4" gives an object with information on the two-letter FIPS_10-4 ID
    # of the country. This is stored as a string in the last two characters of the first
    # line, so we can use str() and indexing to retrieve this code, assigned to fips.
    fips = str(countries.loc[countries["Name"] == country]["FIPS_10-4"]).split('\n')[0][-2:]
    
    # Now we create part of the query string using string concatenation and the given
    # parameters. This string has the following format:
    # WHERE T.Year BETWEEN {year_begin} AND {year_end} AND T.Month = {month} AND Country = {fips}
    where = "WHERE Year BETWEEN " + str(year_begin) + " AND " + str(year_end) + \
            " AND Month = " + str(month) + " AND Country = '" + fips + "'"
    
    # Connect to the database "temps.db" to be queried.
    conn = sqlite3.connect("temps.db")

    # In the query, we use LEFT JOIN to extract information from both the stations and temperatures
    # tables in the database, merging these two tables' information based on matching station IDs.
    # We SELECT the NAME, LATITUDE, LONGITUDE, and first two letters of the ID (renamed Country) 
    # columns from the stations table, and Year, Month, and Temp columns from the temperatures table.
    # Finally, we add the WHERE string created earlier.
    cmd = "SELECT NAME, LATITUDE, LONGITUDE, SUBSTRING(S.id, 1, 2) Country, Year, Month, Temp \
           FROM stations S \
           LEFT JOIN temperatures T ON S.id = T.id " + where

    # Use the pandas function read_sql() to read the query of this database into a DataFrame df
    # to be returned. 
    df = pd.read_sql(cmd, conn)
    
    # Always close the database.
    conn.close()

    return df
```

We'll test out this function by querying the stations in India between the years 1980 and 2020, in the month 1 (January), and displaying the result.


```python
df = query_climate_database(country = "India", 
                            year_begin = 1980, 
                            year_end = 2020,
                            month = 1)
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>NAME</th>
      <th>LATITUDE</th>
      <th>LONGITUDE</th>
      <th>Country</th>
      <th>Year</th>
      <th>Month</th>
      <th>Temp</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>IN</td>
      <td>1980</td>
      <td>1</td>
      <td>23.48</td>
    </tr>
    <tr>
      <th>1</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>IN</td>
      <td>1981</td>
      <td>1</td>
      <td>24.57</td>
    </tr>
    <tr>
      <th>2</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>IN</td>
      <td>1982</td>
      <td>1</td>
      <td>24.19</td>
    </tr>
    <tr>
      <th>3</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>IN</td>
      <td>1983</td>
      <td>1</td>
      <td>23.51</td>
    </tr>
    <tr>
      <th>4</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>IN</td>
      <td>1984</td>
      <td>1</td>
      <td>24.81</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>3147</th>
      <td>DARJEELING</td>
      <td>27.050</td>
      <td>88.270</td>
      <td>IN</td>
      <td>1983</td>
      <td>1</td>
      <td>5.10</td>
    </tr>
    <tr>
      <th>3148</th>
      <td>DARJEELING</td>
      <td>27.050</td>
      <td>88.270</td>
      <td>IN</td>
      <td>1986</td>
      <td>1</td>
      <td>6.90</td>
    </tr>
    <tr>
      <th>3149</th>
      <td>DARJEELING</td>
      <td>27.050</td>
      <td>88.270</td>
      <td>IN</td>
      <td>1994</td>
      <td>1</td>
      <td>8.10</td>
    </tr>
    <tr>
      <th>3150</th>
      <td>DARJEELING</td>
      <td>27.050</td>
      <td>88.270</td>
      <td>IN</td>
      <td>1995</td>
      <td>1</td>
      <td>5.60</td>
    </tr>
    <tr>
      <th>3151</th>
      <td>DARJEELING</td>
      <td>27.050</td>
      <td>88.270</td>
      <td>IN</td>
      <td>1997</td>
      <td>1</td>
      <td>5.70</td>
    </tr>
  </tbody>
</table>
<p>3152 rows × 7 columns</p>
</div>



## 3. Write a Geographic Scatter Function for Yearly Temperature Increases

Now, we want to use our query function to create a visualization that answers the following question:

> **How does the average yearly change in temperature vary within a given country?** 

Our query already gives data on stations with specified countries and months, across a range of years, but to retreive the average yearly change, we need the slope of a best-fit line of the temperature against year data. We'll do this using the `LinearRegression model` from `sklearn.linear_model` and defining a function `coef()`


```python
from sklearn.linear_model import LinearRegression

def coef(data_group):
    """
    Given quantitative data on temperature and year, creates a linear regression model to
    fit the data and returns the slope of the best-fit line.
    
    Parameters
    ----------
    data_group: data object containing temperature and year data
    
    Return
    ------
    slope: float, slope of the fitted line
    """
    
    X = data_group[["Year"]] # lin reg expects this to be data frame, so use 2 brackets
    y = data_group["Temp"] # y should be a series, so only use one bracket
    
    # create the linear regression model object and fit the data
    LR = LinearRegression()
    LR.fit(X, y) 
    
    slope = LR.coef_[0] # extract the slope from the coef_ property
    
    return slope
```

And, for later, we will define a month dictionary that corresponds the numbers 1 to 12 to each month of the year.


```python
month_dict = {1: "January",
              2: "February",
              3: "March",
              4: "April",
              5: "May",
              6: "June",
              7: "July",
              8: "August",
              9: "September",
              10: "October",
              11: "November",
              12: "December"}
```

Now, we define `temperature_coefficient_plot` that creates a plotly scatter mapbox visualization.


```python
def temperature_coefficient_plot(country, year_begin, year_end, month, min_obs, **kwargs):
    """
    Uses query_climate_database() to create a DataFrame with information on 
    station temperatures of a specified country, year range, and month, limited 
    to stations with at least min_obs entries (years of data). For each station,
    calculates the average yearly change in temperature using the coef() function
    above. Then, plots each station on an interactive map using scatter_mapbox(), 
    with colors distinguishing each station's average yearly change in temperature.
    
    Parameters
    ----------
    country, year_begin, year_end, and month are exactly the same as in 
    query_climate_database().
    
     min_obs: int, the minimum number of entries (years of data) a station must 
              have to be included in the visualization.
    **kwargs: additional keyword arguments that can be used to customize the 
              scatter_mapbox function call
             
    Return
    ------
         fig: the completed plotly scatter mapbox figure
    """
    
    # Use query_climate_database() and the specified parameters to create the DataFrame
    df = query_climate_database(country, year_begin, year_end, month)
    
    # Create a new column of the DataFrame that labels each station with its number
    # of observations. This is done by grouping df by "NAME" of the stations, noting 
    # the length of the "Temp" column (the number of temperature observations), and
    # using transform() (which preserves the length of the group) to apply this 
    # information to each entry in the group in a new column "Count".
    df["Count"] = df.groupby(["NAME"])["Temp"].transform(len)
    
    # Only select the stations whose "Count" (number of observations) are greater than
    # or equal to the specified min_obs.
    df = df[df["Count"] >= min_obs]
    
    # Create a DataFrame named coefs that includes information on the average yearly 
    # change in temperature of each station, by using apply() and the function coef()
    coefs = df.groupby(["NAME"]).apply(coef)
    coefs = coefs.reset_index()
    
    # Round the averages (in a column called 0) to 4 decimal points, and rename the
    # column to something more informative.
    coefs[0] = coefs[0].round(4)
    coefs = coefs.rename(columns = {0: "Estimated Yearly Increase (ºC)"})
    
    # Use merge() to add the averages to df, where the merge is done on the "NAME"
    # of the stations, so each unique station receives its unique average value.
    df = df.merge(coefs, how = "inner", left_on = "NAME", right_on = "NAME")

    # Create an informative title that will be displayed on the figure. This uses
    # the paramaters country, year_begin, year_end, and indexing month_dict to retreive 
    # the month associated with the integer [month].
    fig_title = "Estimates of yearly increase in temperature in " + \
                month_dict[month] + " for stations in " + country + \
                ", years " + str(year_begin) + " - " + str(year_end)
    
    # Create the figure with px.scatter_mapbox().
    fig = px.scatter_mapbox(df, # the DataFrame from which data can be used
                            lat = "LATITUDE", # Use latitude information from the LATITUDE column
                            lon = "LONGITUDE", # Use longitude information from the LONGITUDE column
                            hover_name = "NAME", # Show each station's NAME when hovering over it
                            # distinguish color of points by average yearly temp increase
                            color = "Estimated Yearly Increase (ºC)",
                            title = fig_title, # make the title the fig_title created above.
                            height = 400, # height of the figure is 400
                            color_continuous_midpoint = 0, # color bar on the right side is centered at 0
                            **kwargs) # pass in any additional **kwargs specified
    return fig
```

We will demonstrate this function by plotting the yearly increase in temperature in January for stations in India between the years 1980 and 2020. We also specify that entries have at least 10 years of data, and we choose a specific mapbox style and color map.


```python
color_map = px.colors.diverging.RdGy_r # choose a colormap

fig = temperature_coefficient_plot(country = "India", 
                                   year_begin = 1980, 
                                   year_end = 2020, 
                                   month = 1, 
                                   min_obs = 10,
                                   zoom = 2,
                                   mapbox_style = "carto-positron", # style has low contrast and little color
                                   color_continuous_scale = color_map) # specify a continuous color spectrum
fig.show()
```

{% include hw1_fig1.html %}


Demonstrating again with the country Japan in the month June, year range 1990-2015, with a different color map.


```python
color_map = px.colors.diverging.Tropic

fig = temperature_coefficient_plot(country = "Japan", 
                                   year_begin = 1990, 
                                   year_end = 2015, 
                                   month = 6, 
                                   min_obs = 10,
                                   zoom = 2,
                                   mapbox_style = "carto-positron",
                                   color_continuous_scale = color_map)
fig.show()
```

{% include hw1_fig2.html %}


## 4. Additional Examples

Now, I will show another example, with a different query function and two different plotting functions making use of the query function that answer the following questions:
> **In a given year and country, how much do the monthly station temperatures vary?**

> **In a given year and country, how do the monthly station temperatures vary with latitude?**


```python
def query_climate_database2(country, year):
    """
    Queries the temps.db database, displaying name, location, date, and temperature information
    of stations in a specified country and year.
    
    Parameters
    ----------
       country: string, the unabbreviated name of the specified country in the query
          year: int, the specified year to be queried
    
    Return
    ------
            df: DataFrame, the completed query as a pandas DataFrame
    """
    
    # Extracts the two-character ID of the country, in the same way as earlier.
    fips = str(countries.loc[countries["Name"] == country]["FIPS_10-4"]).split('\n')[0][-2:]
    
    # Again we create the WHERE part of the query using string concatenation. This has the format
    # WHERE T.Year BETWEEN {year_begin} AND {year_end} AND T.Month = {month} AND Country = {fips}
    where = "WHERE Year = " + str(year) + " AND Country = '" + fips + "'"
    
    conn = sqlite3.connect("temps.db") # Connect to the database.

    # Forming the query string in the same way as before, with the WHERE string above.
    cmd = "SELECT NAME, LATITUDE, LONGITUDE, SUBSTRING(S.id, 1, 2) Country, Year, Month, Temp \
           FROM stations S \
           LEFT JOIN temperatures T ON S.id = T.id " + where

    df = pd.read_sql(cmd, conn) # Read the query into a DataFrame.
    
    conn.close() # Close the connection.

    return df
```

As an example, I'll query the stations in India in 2015 and display the result.


```python
df = query_climate_database2(country = "India", year = 2015)
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>NAME</th>
      <th>LATITUDE</th>
      <th>LONGITUDE</th>
      <th>Country</th>
      <th>Year</th>
      <th>Month</th>
      <th>Temp</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>IN</td>
      <td>2015</td>
      <td>1</td>
      <td>24.90</td>
    </tr>
    <tr>
      <th>1</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>IN</td>
      <td>2015</td>
      <td>2</td>
      <td>26.62</td>
    </tr>
    <tr>
      <th>2</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>IN</td>
      <td>2015</td>
      <td>3</td>
      <td>30.50</td>
    </tr>
    <tr>
      <th>3</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>IN</td>
      <td>2015</td>
      <td>4</td>
      <td>31.93</td>
    </tr>
    <tr>
      <th>4</th>
      <td>PBO_ANANTAPUR</td>
      <td>14.583</td>
      <td>77.633</td>
      <td>IN</td>
      <td>2015</td>
      <td>5</td>
      <td>32.41</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>935</th>
      <td>SILCHAR</td>
      <td>24.820</td>
      <td>92.830</td>
      <td>IN</td>
      <td>2015</td>
      <td>4</td>
      <td>25.95</td>
    </tr>
    <tr>
      <th>936</th>
      <td>TRIVANDRUM</td>
      <td>8.500</td>
      <td>77.000</td>
      <td>IN</td>
      <td>2015</td>
      <td>1</td>
      <td>27.50</td>
    </tr>
    <tr>
      <th>937</th>
      <td>TRIVANDRUM</td>
      <td>8.500</td>
      <td>77.000</td>
      <td>IN</td>
      <td>2015</td>
      <td>2</td>
      <td>28.50</td>
    </tr>
    <tr>
      <th>938</th>
      <td>TRIVANDRUM</td>
      <td>8.500</td>
      <td>77.000</td>
      <td>IN</td>
      <td>2015</td>
      <td>3</td>
      <td>29.20</td>
    </tr>
    <tr>
      <th>939</th>
      <td>TRIVANDRUM</td>
      <td>8.500</td>
      <td>77.000</td>
      <td>IN</td>
      <td>2015</td>
      <td>4</td>
      <td>28.80</td>
    </tr>
  </tbody>
</table>
<p>940 rows × 7 columns</p>
</div>



In the first plot function, I'll answer the first question,
> **In a given year and country, how much do the monthly station temperatures vary?** 

This will be done by calculating the standard deviation of the monthly temperatures of each station in the given year.


```python
def temperature_std_plot(country, year, min_obs, **kwargs):
    """
    Uses query_climate_database2() to create a DataFrame with information on 
    station temperatures of a specified country and month, limited to stations 
    with at least min_obs entries (months of data). For each station,
    calculates the standard deviation in temperature using the numpy std function. 
    Then, plots each station on an interactive map using scatter_mapbox(), 
    with colors distinguishing each station's standard deviation.
    
    Parameters
    ----------
    country and year are exactly the same as in query_climate_database2().
    
     min_obs: int, between 1 and 12 indicating the minimum number of entries 
              (months of data) a station must have to be included in the visualization.
              (12 is recommended so that each station plotted has a full year's worth
              of data to calculate standard deviation)
    **kwargs: additional keyword arguments that can be used to customize the 
              scatter_mapbox function call
             
    Return
    ------
         fig: the completed plotly scatter mapbox figure
    """
    
    # Use query_climate_database2() and the specified parameters to create the DataFrame
    df = query_climate_database2(country, year)
    
    # As before, create a new column "Count" in the DataFrame and only select stations 
    # with at least min_obs many entries.
    df["Count"] = df.groupby(["NAME"])["Temp"].transform(len)
    df = df[df["Count"] >= min_obs]
    
    # Use groupby() to group the DataFrame by station, and use aggregate() along with the
    # numpy function std() to calculate the standard deviation of the "Temp" column
    # of each group. Rename the column to something more informative.
    std = df.groupby(["NAME"])["Temp"].aggregate([np.std])
    std = std.rename(columns = {"std" : "Standard Deviation"})
                           
    # As before, use merge() to add the standard deviation measurements to each unique 
    # station in df.
    df = df.merge(std, how = 'inner', left_on = 'NAME', right_on = 'NAME')
    
    # Create an informative title using the specified country and year.
    fig_title = "Standard deviation of monthly temperatures for stations in " + \
                country + " in the year " + str(year)
    
    # As before, create the figure with px.scatter_mapbox().
    fig = px.scatter_mapbox(df,
                            lat = "LATITUDE",
                            lon = "LONGITUDE",
                            hover_name = "NAME",
                            color = "Standard Deviation",
                            title = fig_title,
                            height = 400,
                            **kwargs)
    return fig
```

Demonstrate this function by plotting the standard deviation of monthly temperatures for stations in India in the year 2015. We can specify that each station have at least 12 entries (months of data) and a custom mapbox style and color map.


```python
color_map = px.colors.diverging.RdGy_r # choose a colormap

fig = temperature_std_plot(country = "India",
                           year = 2015, 
                           min_obs = 12,
                           zoom = 2,
                           mapbox_style = "carto-positron", # style has low contrast and little color
                           color_continuous_scale = color_map) # specify a continuous color spectrum
fig.show()
```

{% include hw1_fig3.html %}


In the second function, I'll answer the second question, 
> **In a given year and country, how do the monthly station temperatures vary with latitude?** 

This will be done by calculating the mean of the monthly temperatures of each station in the given year, and plotting them against latitude.


```python
def temperature_mean_plot(country, year, min_obs, **kwargs):
    """
    Uses query_climate_database2() to create a DataFrame with information on 
    station temperatures of a specified country and month, limited to stations 
    with at least min_obs entries (months of data). For each station,
    calculates the average temperature using the numpy mean function. 
    Then, plots each station's average temperature against latitude on an 
    interactive scatter plot using scatter(), with colors distinguishing each 
    station.
    
    Parameters
    ----------
    country and year are exactly the same as in query_climate_database2().
    
     min_obs: int, between 1 and 12 indicating the minimum number of entries 
              (months of data) a station must have to be included in the visualization.
              (12 is recommended so that each station plotted has a full year's worth
              of data to calculate standard deviation)
    **kwargs: additional keyword arguments that can be used to customize the 
              scatter() function call
             
    Return
    ------
         fig: the completed plotly scatter mapbox figure
    """
    
    # Use query_climate_database2() and the specified parameters to create the DataFrame
    df = query_climate_database2(country, year)
    
    # As before, create a new column "Count" in the DataFrame and only select stations 
    # with at least min_obs many entries.
    df['Count'] = df.groupby(["NAME"])["Temp"].transform(len)
    df = df[df['Count'] >= min_obs]
    
    # Use groupby() to group the DataFrame by station, and use aggregate() along with the
    # numpy function mean() to calculate the average of the "Temp" column of each group. 
    # Rename the column to something more informative.
    mean = df.groupby(["NAME"])["Temp"].aggregate([np.mean])
    mean = mean.rename(columns = {"mean" : "Average Temperature"})
                     
    # As before, use merge() to add the standard deviation measurements to each unique 
    # station in df.
    df = df.merge(mean, how = 'inner', left_on = 'NAME', right_on = 'NAME')
    
    # Create an informative title using the specified country and year.
    fig_title = "Average monthly temperature against latitude for stations in " + \
                country + " in the year " + str(year)
    
    # Create the figure with px.scatter().
    fig = px.scatter(df, # the DataFrame from which data will be used
                     x = "LATITUDE", # the column of the DataFrame to be plotted along the x-axis
                     y = "Average Temperature", # the column of the DataFrame to be plotted along the y-axis
                     color = "NAME", # distinguish color of points by station
                     height = 400, # height of the figure is 400
                     title = fig_title, # use the title from above
                     **kwargs) # pass in the additional specified keyword arguments to customize the plot
    return fig
```

Demonstrate this function by plotting the average monthly temperatures against latitude for stations in Japan in the year 2015. Each station should have at least 12 entries (months of data).


```python
fig = temperature_mean_plot("Japan", 2015, 12)

fig.show()
```

{% include hw1_fig4.html %}

