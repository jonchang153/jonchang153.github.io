---
layout: post
title: Web Development with Flask
---

In this blog post, I'll demonstrate how to create a web app with Flask. In particular, we'll be creating a message bank that accepts, stores, and displays user-inputted messages, utilizing a SQL database.


## Setting Up Project

The folder holding the necessary files will require an `app.py` file containing the Python code that runs the Flask app. This code will run when `flask run` is called in the terminal. 

We'll also need a `templates` folder that contains various .html files, corresponding to various pages of our website. In particular, we'll be creating `main.html`, `submit.html`, and `view.html` files, corresponding to the pages when /, /submit/, and /view/ are appended to the end of our website's url, respectively. We'll also need a `base.html` file containing html from which each of the previous pages will add onto, or extend. This will use a tool called Jinja; see [here](https://jinja.palletsprojects.com/en/3.1.x/){:target="_blank"} for more.

Finally, there is an optional `static` folder that can hold a `style.css` file. This can be used to style the webpage, which I'll go into more detail about later.


## Implementing `app.py`

We'll begin by importing the necessary packages and creating our web app.
```python
from flask import Flask, g, render_template, request
import sqlite3

app = Flask(__name__)
```

### Main Page

Next, we'll define a function that describes the behavior of the webpage when the main page is accessed. In this case, we only want the webpage to render the `main.html` file, and nothing else. This uses the `render_template()` function from flask.

```python
# specify that the below function will be called when '/' is appended to the webpage's URL
@app.route('/')
def main():
    return render_template('main.html')
```

### Submit Page

Next, we'll define the behavior of the submit page. First, we'll need two helper functions, `get_message_db()` and `insert_message()`. The first function uses sqlite3 to create a database that will hold the messages the first time it's called, and returns a connection to the database every subsequent call.

```python
def get_message_db():
    try:
        return g.message_db # return the database if it already exists

    except: # otherwise, initialize the database

        # create the messages_db.sqlite database
        g.message_db = sqlite3.connect("messages_db.sqlite")

        # use a sqlite command to create a table called "messages" with three columns
        cmd = \
        """
        CREATE TABLE IF NOT EXISTS messages (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            message TEXT NOT NULL,
            handle TEXT NOT NULL)
        """

        # create a cursor object referencing the database and execute the command
        cursor = g.message_db.cursor()
        cursor.execute(cmd)

        return g.message_db
```

The next function will be called when the user submits the web form on the submit page, and inserts their submissions into the database.

```python
def insert_message():

    # use request object to get the user's input for 'message',
    # the name attribute corresponding to the textarea tag
    # that holds the user's message
    message = request.form['message']

    # use request object to get the user's input for 'handle',
    # the name attribute corresponding to the textbox tag
    # that holds the user's handle
    handle = request.form['handle']

    # open a connection to the database with the previously defined function
    conn = get_message_db()

    # create a sqlite command that inserts the user's message and handle 
    # into the database
    cmd = \
    f"""
    INSERT INTO messages (message, handle) 
    VALUES ('{message}', '{handle}')
    """

    # create a cursor object referencing the database and execute the command
    cursor = conn.cursor()
    cursor.execute(cmd)

    # use commit() to save the changes to the database, and close the connection
    conn.commit()
    conn.close()

    return message, handle
```

Finally, we'll define the `submit()` function, which simply renders the submit page when only a GET request is made; otherwise, it makes a call to `insert_message()` and renders the page with the return values of the `insert_message()` function.

```python
# specify that the below function will be called when '/submit/' is appended to the 
# webpage's URL; also specify that this function will make use of POST and GET methods
@app.route('/submit/', methods=['POST', 'GET'])
def submit():

    # render the page if the user only accesses the webpage without submitting a form
    if request.method == 'GET':
        return render_template('submit.html')

    # otherwise, the user submitted the form
    else:
        try: # call insert_message() and save its return values
            message, handle = insert_message()

            # render the page with various defined variables that can be used by Jinja
            # to manipulate the webpage
            return render_template('submit.html', submitted=True, message=message, handle=handle)

        except: # if an error occurred, render the webpage while specifying the error
            return render_template('submit.html', error=True)
```


### View Page

Now, we will define the behavior of the view page. This requires one helper function, `random_messages()`, which accesses the database and randomly pulls a specified number of entries from the database. This function makes use of a sqlite query that can be found [here](https://stackoverflow.com/questions/2279706/select-random-row-from-a-sqlite-table){:target="_blank"}.

```python
def random_messages(n):

    # connect to the database with the previously defined function
    conn = get_message_db()

    # create a sqlite command that randomly selects n many entries from the 
    # messages table, n being specified by the function call
    cmd = \
    f"""
    SELECT * FROM messages ORDER BY RANDOM() LIMIT {n}
    """

    # create a cursor object referencing the database and execute the command
    cursor = conn.cursor()
    cursor.execute(cmd)

    # fetchall() the selections, assign it to result, and close the connection
    result = cursor.fetchall()
    conn.close()

    return result
```

Then, the `view()` function makes use of the `random_messages()` function to render the view page.

```python
# specify that the below function will be called when '/view/' is appended to the 
# webpage's URL
@app.route('/view/')
def view(): 
    # render the page with a messages variable that holds the result of a call to
    # random_messages() with argument 5
    return render_template('view.html', messages=random_messages(5))
```


## Implementing `templates`

Now, we will implement the actual `base.html`, `main.html`, `submit.html`, and `view.html` templates that are displayed when the web app runs. This makes use of Jinja; you can find a synopsis of the documentation [here](https://jinja.palletsprojects.com/en/3.0.x/templates/){:target="_blank"}.

### `base.html` template

We'll begin with implementing the `base.html` file, which most resembles a typical html file. Notice that we specify the `style.css` styling in the `<link>` tag. There are various Jinja blocks where child templates can later add to or override. Most importantly, the content of each webpage will be placed in the `{% raw %}{% block content %}{% endraw %}` block, inside a `<section>` tag.

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="stylesheet" href="{% raw %}{{ url_for('static', filename='style.css') }}{% endraw %}">
    <title>{% raw %}{% block title %}{% endblock %}{% endraw %} - Message Bank</title>
  </head>

  <body>
    <header>
      <h1>Message Bank</h1>
    </header>

    <main>
      <nav>
        {% raw %}{% block nav %}{% endblock %}{% endraw %}
      </nav>

      <section class="content">
        <header>
          {% raw %}{% block header %}{% endblock %}{% endraw %}
        </header>
        {% raw %}{% block content %}{% endblock %}{% endraw %}
      </section>
    </main>

    <footer>
      <hr>
      <small>
        &copy; UCLA, 2022
      </small>
    </footer>
  </body>

</html>
```

Although I won't go into much detail, I have pasted below the implementations for the `main.html`, `submit.html`, and `view.html` files. Notice that each one `{% raw %}{% extends 'base.html' %}{% endraw %}` in the first line. Everything above the 'CONTENT BEGINS HERE' comment specifies the page/tab headings, as well as which page is currently "active", which will be used later for CSS styling. Everything below the 'CONTENT BEGINS HERE' comment is the content of the page.

### `main.html` template

In the `main.html` file, the content simply displays a message to access the submit page.


```html
{% raw %}{% extends 'base.html' %}{% endraw %}
{% raw %}{% block title %}{% endraw %}Main{% raw %}{% endblock %}{% endraw %}

{% raw %}{% block nav %}{% endraw %}
<ul>
  <li><a href="{% raw %}{{ url_for('submit') }}{% endraw %}">Submit a message</a></li>
  <li><a href="{% raw %}{{ url_for('view') }}{% endraw %}">View messages</a></li>
</ul>
{% raw %}{% endblock %}{% endraw %}

{% raw %}{% block header %}{% endraw %}<h2>Main Page</h2>{% raw %}{% endblock %}{% endraw %}

<!-- CONTENT BEGINS HERE -->

{% raw %}{% block content %}{% endraw %}
  Please click "Submit a message" or append "/submit/" to the url to access the submit page.
{% raw %}{% endblock %}{% endraw %}
```

### `submit.html` template

In the `submit.html` file, there is html specifying a `<form>` tag, which will be submitted when the user makes a post request. Also notice the textarea element with name 'message', and the textbox element with name 'handle'; these are the names used to access the submissions, as done in the `insert_message()` function. Jinja also makes use of the `submitted`, `message`, `handle`, and `error` variables that may be passed when rendering this page; these variables can be used in control flow to manipulate the html.

```html
{% raw %}{% extends 'base.html' %}{% endraw %}
{% raw %}{% block title %}{% endraw %}Submit{% raw %}{% endblock %}{% endraw %}

{% raw %}{% block nav %}{% endraw %}
<ul>
  <li><a href="{% raw %}{{ url_for('submit') }}{% endraw %}" class="active">Submit a message</a></li>
  <li><a href="{% raw %}{{ url_for('view') }}{% endraw %}">View messages</a></li>
</ul>
{% raw %}{% endblock %}{% endraw %}

{% raw %}{% block header %}{% endraw %}<h2>Submit a message</h2>{% raw %}{% endblock %}{% endraw %}

<!-- CONTENT BEGINS HERE -->

{% raw %}{% block content %}{% endraw %}
  <form method="post">
      <label for="message">Your message:</label><br>
      <textarea name="message" id="message"></textarea>
      <br><br>
      <label for="handle">Your name or handle:</label><br>
      <input type="text" name="handle" id="handle">
      <br><br>
      <input type="submit" value="Submit message">
  </form>

  {% raw %}{% if submitted %}{% endraw %}
    <br>
    You have successfully submitted the following message, along with the following handle:
    <br><br>
    "{% raw %}{{ message }}{% endraw %}"
    <br>
    <i>- {% raw %}{{ handle }}{% endraw %}</i>
  {% raw %}{% endif %}{% endraw %}

  {% raw %}{% if error %}{% endraw %}
    <br>
    There was an error with the submission. Please try again.
  {% raw %}{% endif %}{% endraw %}
{% raw %}{% endblock %}{% endraw %}
```

### `view.html` template

The `view.html` file's content uses Jinja to view the contents of the `messages` container passed to the page. The container is looped through, and indexing is used to access the id, message, and handle of each message stored in the container.

```html
{% raw %}{% extends 'base.html' %}{% endraw %}
{% raw %}{% block title %}{% endraw %}View{% raw %}{% endblock %}{% endraw %}

{% raw %}{% block nav %}{% endraw %}
<ul>
  <li><a href="{% raw %}{{ url_for('submit') }}{% endraw %}">Submit a message</a></li>
  <li><a href="{% raw %}{{ url_for('view') }}{% endraw %}" class="active">View messages</a></li>
</ul>
{% raw %}{% endblock %}{% endraw %}

{% raw %}{% block header %}{% endraw %}<h2>View messages</h2>{% raw %}{% endblock %}{% endraw %}

<!-- CONTENT BEGINS HERE -->

{% raw %}{% block content %}{% endraw %}
  This is a list of up to 5 random messages in the database. The number gives the order in which they were submitted.
  <br>
  {% raw %}{% for message in messages %}{% endraw %}
    <br>
    <b>{% raw %}{{ message[0] }}{% endraw %}:</b> "{% raw %}{{ message[1] }}{% endraw %}"
    <br>
    <i>- {% raw %}{{ message[2] }}{% endraw %}</i>
    <br>
  {% raw %}{% endfor %}{% endraw %}
{% raw %}{% endblock %}{% endraw %}
```

## Styling

Optionally, we can add CSS styling to our web app. I've added a different font to the entirety of my web page, as well as styled my navigation bar to have a different color and flash differently when hovered/active (this is the use of the `class="active"` attribute specified in each of the html files above). You can see my CSS implementation in [my Github project repository](https://github.com/jonchang153/flask-web-dev){:target="_blank"}, along with the rest of the files to implement this web app.


## Run Your Web App

Finally, we are ready to run our website. Paste the following commands into the terminal. Make sure you are in the correct directory.

```
export FLASK_ENV=development
flask run
```

Copying the link to the local address, we arrive at the main page:

![HW5_1](/images/HW5-1.png)

Now, we'll redirect to the submit page, and type in a sample message for our message bank.

![HW5_2](/images/HW5-2.png)

After pressing the "Submit message" button, a note appears to indicate that the submission was successful.

![HW5_3](/images/HW5-3.png)

We'll redirect to the view page to view the submission that was just made.

![HW5_4](/images/HW5-4.png)

After a few more submissions, the view page now looks like this:

![HW5_5](/images/HW5-5.png)

